---
title: "Finitely generated classes of series ğŸš§"
---

```
{-# OPTIONS --guardedness --sized-types #-}
-- --allow-unsolved-metas

open import Preliminaries.Base renaming (_,,_ to _,_)
open import General.ProductRules

module General.FinitelyGenerated
    (R : CommutativeRing)
    (Î£ : Set)
    (productRule : ProductRule R)
    where

open import Size

open import Preliminaries.Vector
open import Preliminaries.Algebra R
open import Preliminaries.PolyExpr R using (con)

open import General.Terms R
    renaming (_+_ to _[+]_; _*_ to _[*]_; _Â·_ to _[Â·]_) -- âŸ¦_âŸ§_ to EâŸ¦_âŸ§_; âŸ¦_âŸ§áµ¥_ to EâŸ¦_âŸ§áµ¥_)

open import General.Series R Î£
open import General.Products R Î£
open Product productRule
open ProductRule productRule

private variable
    X : Set
    m n : â„•
    f g : A âŸª Î£ âŸ«
    -- Ï± : SEnv âˆ X
    gs : Vec (A âŸª Î£ âŸ«) n
```

# *-finite series

## Finitely genereated algebras of series

```
-- finitely generated algebra
infix 4 _âˆˆ[_] [_]âˆ‹_
infixr 8 _Â·âˆˆ_
infixr 6 _+âˆˆ_
infixr 7 _*âˆˆ_
infixr 8 _â‰ˆâˆˆ_

-- (abstract) algebra finitely generated by a list of generators
data [_]âˆ‹_ (gs : Vec (A âŸª Î£ âŸ«) n) : A âŸª Î£ âŸ« â†’ Set where
    ğŸ˜âˆˆ : [ gs ]âˆ‹ ğŸ˜
    genâˆˆ : g âˆˆ gs â†’ [ gs ]âˆ‹ g
    _Â·âˆˆ_ : âˆ€ c â†’ [ gs ]âˆ‹ f â†’ [ gs ]âˆ‹ c Â· f
    _+âˆˆ_ : [ gs ]âˆ‹ f â†’ [ gs ]âˆ‹ g â†’ [ gs ]âˆ‹ f + g
    _*âˆˆ_ : [ gs ]âˆ‹ f â†’ [ gs ]âˆ‹ g â†’ [ gs ]âˆ‹ f * g
    -- closure under equivalence of series
    -- we need to assume this since the base ring is parametrised by an equivalence relation
    _â‰ˆâˆˆ_ : f â‰ˆ g â†’ [ gs ]âˆ‹ g â†’ [ gs ]âˆ‹ f

_âˆˆ[_] : (f : A âŸª Î£ âŸ«) (gs : Vec (A âŸª Î£ âŸ«) n) â†’ Set
f âˆˆ[ gs ] = [ gs ]âˆ‹ f
```

```
-- every polynomial combination of the generators is in the algebra they generate
subalgebra :
    âˆ€ {Ï±} (p : Term X) â†’
    (âˆ€ x â†’ Ï± x âˆˆ[ gs ]) â†’
    ---------------------
    âŸ¦ p âŸ§ Ï± âˆˆ[ gs ]

subalgebra 0T _ = ğŸ˜âˆˆ
subalgebra (var x) ass = ass x
subalgebra (c [Â·] p) ass = _ Â·âˆˆ subalgebra p ass
subalgebra (p [+] q) ass = subalgebra p ass +âˆˆ subalgebra q ass
subalgebra (p [*] q) ass = subalgebra p ass *âˆˆ subalgebra q ass

-- for every series f belonging to a finitely generated algebra
-- we can compute a term whose semantics is f
extract : âˆ€ f (gs : Vec (A âŸª Î£ âŸ«) n) â†’ f âˆˆ[ gs ] â†’ âˆƒ[ Î± ] f â‰ˆ âŸ¦ Î± âŸ§ (lookup gs)
extract {n} f gs fâˆˆ[gs] = go f fâˆˆ[gs] where

    -- there are n variables
    Y : Set
    Y = Fin n

    -- if f belongs to a finitely generated algebra,
    -- then it can be expressed as a polynomial in the generators
    go : âˆ€ f â†’ f âˆˆ[ gs ] â†’ âˆƒ[ Î± ] f â‰ˆ âŸ¦ Î± âŸ§ (lookup gs)
    go f ğŸ˜âˆˆ = 0T , â‰ˆ-refl
    go f (genâˆˆ fâˆˆgs) = var i , fâ‰ˆâŸ¦iâŸ§Ï± where

        -- index of f in gs
        i : Y
        i with lookup-âˆˆ fâˆˆgs
        ... | i , _ = i

        -- proof that f indeed is element i of gsâ€²
        fâ‰¡Ï±i : f â‰¡ lookup gs i
        fâ‰¡Ï±i with lookup-âˆˆ fâˆˆgs
        ... | _ , eq = eq

        fâ‰ˆâŸ¦iâŸ§Ï± : f â‰ˆ âŸ¦ var i âŸ§ (lookup gs)
        fâ‰ˆâŸ¦iâŸ§Ï± = â‰¡â†’â‰ˆ fâ‰¡Ï±i

    go f (c Â·âˆˆ fâˆˆ[gs])
        with go _ fâˆˆ[gs]
    ... | Î± , fâ‰ˆâŸ¦Î±âŸ§ = c [Â·] Î± , Â·-cong R-refl fâ‰ˆâŸ¦Î±âŸ§

    go f (fâˆˆ[gs] +âˆˆ gâˆˆ[gs])
        with go _ fâˆˆ[gs] | go _ gâˆˆ[gs]
    ... | Î± , fâ‰ˆâŸ¦Î±âŸ§ | Î² , gâ‰ˆâŸ¦Î²âŸ§ = Î± [+] Î² , +-cong fâ‰ˆâŸ¦Î±âŸ§ gâ‰ˆâŸ¦Î²âŸ§
    
    go f (fâˆˆ[gs] *âˆˆ gâˆˆ[gs])
        with go _ fâˆˆ[gs] | go _ gâˆˆ[gs]
    ... | Î± , fâ‰ˆâŸ¦Î±âŸ§ | Î² , gâ‰ˆâŸ¦Î²âŸ§ = Î± [*] Î² , *-cong fâ‰ˆâŸ¦Î±âŸ§ gâ‰ˆâŸ¦Î²âŸ§

    go f (fâ‰ˆg â‰ˆâˆˆ fâˆˆ[gs])
        with go _ fâˆˆ[gs]
    ... | Î± , gâ‰ˆâŸ¦Î±âŸ§ = Î± , â‰ˆ-trans fâ‰ˆg gâ‰ˆâŸ¦Î±âŸ§
```

Auxiliary properties.

```
++-âˆˆË¡ : âˆ€ {fs : Vec (A âŸª Î£ âŸ«) m} {gs : Vec (A âŸª Î£ âŸ«) n} â†’ f âˆˆ[ fs ] â†’ f âˆˆ[ fs ++ gs ]
++-âˆˆË¡ ğŸ˜âˆˆ = ğŸ˜âˆˆ
++-âˆˆË¡ (genâˆˆ fâˆˆfs) = genâˆˆ (âˆˆ-++âºË¡ fâˆˆfs)
++-âˆˆË¡ (c Â·âˆˆ fâˆˆ[fs]) = c Â·âˆˆ ++-âˆˆË¡ fâˆˆ[fs]
++-âˆˆË¡ (fâˆˆ[fs] +âˆˆ gâˆˆ[fs]) = ++-âˆˆË¡ fâˆˆ[fs] +âˆˆ ++-âˆˆË¡ gâˆˆ[fs]
++-âˆˆË¡ (fâˆˆ[fs] *âˆˆ gâˆˆ[fs]) = ++-âˆˆË¡ fâˆˆ[fs] *âˆˆ ++-âˆˆË¡ gâˆˆ[fs]
++-âˆˆË¡ (fâ‰ˆg â‰ˆâˆˆ gâˆˆ[fs]) = fâ‰ˆg â‰ˆâˆˆ ++-âˆˆË¡ gâˆˆ[fs]

++-âˆˆÊ³ : âˆ€ {fs : Vec (A âŸª Î£ âŸ«) m} {gs : Vec (A âŸª Î£ âŸ«) n} â†’ f âˆˆ[ gs ] â†’ f âˆˆ[ fs ++ gs ]
++-âˆˆÊ³ ğŸ˜âˆˆ = ğŸ˜âˆˆ
++-âˆˆÊ³ (genâˆˆ fâˆˆfs) = genâˆˆ (âˆˆ-++âºÊ³ _ fâˆˆfs)
++-âˆˆÊ³ (c Â·âˆˆ fâˆˆ[fs]) = c Â·âˆˆ ++-âˆˆÊ³ fâˆˆ[fs]
++-âˆˆÊ³ (fâˆˆ[fs] +âˆˆ gâˆˆ[fs]) = ++-âˆˆÊ³ fâˆˆ[fs] +âˆˆ ++-âˆˆÊ³ gâˆˆ[fs]
++-âˆˆÊ³ (fâˆˆ[fs] *âˆˆ gâˆˆ[fs]) = ++-âˆˆÊ³ fâˆˆ[fs] *âˆˆ ++-âˆˆÊ³ gâˆˆ[fs]
++-âˆˆÊ³ (fâ‰ˆg â‰ˆâˆˆ gâˆˆ[fs]) = fâ‰ˆg â‰ˆâˆˆ ++-âˆˆÊ³ gâˆˆ[fs]
```

## Official definition of *-finite series

```
module OfficialDefinition where

    infix 3 *-Fin[_,_,_]
    record *-Fin (f : A âŸª Î£ âŸ«) (n : â„•) : Set where
        constructor *-Fin[_,_,_]
        field
            gen : Vec (A âŸª Î£ âŸ«) n
            memb : f âˆˆ[ gen ]
            closed : âˆ€ a {g} â†’ g âˆˆ[ gen ] â†’ Î´ g a âˆˆ[ gen ]

        elem : A âŸª Î£ âŸ«
        elem = f

    open *-Fin
```

## Working definition of *-finite series

```
module WorkingDefinition where

    -- simplified definition of *-finite series
    -- this is our working definition
    infix 3 *-Fin[_,_,_]
    record *-Fin (f : A âŸª Î£ âŸ«) (n : â„•) : Set where
        constructor *-Fin[_,_,_]
        field
            gen : Vec (A âŸª Î£ âŸ«) n
            memb : f âˆˆ[ gen ]
            closed : âˆ€ a {g} â†’ g âˆˆ gen â†’ Î´ g a âˆˆ[ gen ]

        elem : A âŸª Î£ âŸ«
        elem = f

    open OfficialDefinition renaming (*-Fin to *-Finâ€²; *-Fin[_,_,_] to *-Finâ€²[_,_,_])
    open *-Fin public

    -- the official and simplified definitions are equivalent
    
    officialâ†’simplified : *-Finâ€² f n â†’ *-Fin f n
    officialâ†’simplified *-Finâ€²[ gen , fâˆˆ[gen] , clâ€² ] =
        *-Fin[ gen , fâˆˆ[gen] , cl ] where
            cl :  âˆ€ a {g} â†’ g âˆˆ gen â†’ Î´ g a âˆˆ[ gen ]
            cl a gâˆˆgen = clâ€² a (genâˆˆ gâˆˆgen)

    Î´-closed : âˆ€ (F : *-Fin f n) a {g} â†’ g âˆˆ[ gen F ] â†’ Î´ g a âˆˆ[ gen F ]
    Î´-closed F a = go where
        go : âˆ€ {g} â†’ g âˆˆ[ gen F ] â†’ Î´ g a âˆˆ[ gen F ]
        go ğŸ˜âˆˆ = ğŸ˜âˆˆ
        go (genâˆˆ gâˆˆgen) = closed F a gâˆˆgen
        go (c Â·âˆˆ gâˆˆ[F]) = c Â·âˆˆ go gâˆˆ[F]
        go (gâˆˆ[F] +âˆˆ hâˆˆ[F]) = go gâˆˆ[F] +âˆˆ go hâˆˆ[F]
        go (_*âˆˆ_ {g} {h} gâˆˆ[gen] hâˆˆ[gen]) = subalgebra P ass where
            ass : (x : Var 4) â†’ lookup (g âˆ· Î´ g a âˆ· h âˆ· Î´ h a âˆ· []) x âˆˆ[ gen F ]
            ass zero = gâˆˆ[gen]
            ass (suc zero) = go gâˆˆ[gen]
            ass (suc (suc zero)) = hâˆˆ[gen]
            ass (suc (suc (suc zero))) = go hâˆˆ[gen]
        go (fâ‰ˆg â‰ˆâˆˆ fâˆˆ[F]) = (Î´-â‰ˆ fâ‰ˆg a) â‰ˆâˆˆ go fâˆˆ[F]

    simplifiedâ†’official : âˆ€ {f} â†’ *-Fin f n â†’ *-Finâ€² f n
    simplifiedâ†’official F = *-Finâ€²[ gen F , memb F , Î´-closed F ] 
                
open WorkingDefinition public
open *-Fin public
```

### Auxiliary properties

```
-- concatenation of generators
infixr 8 _++-gen_
_++-gen_ : *-Fin f m â†’ *-Fin g n â†’ Vec (A âŸª Î£ âŸ«) (m +â„• n)
F ++-gen G = gen F ++ gen G

infixr 8 _++-memb-+_ _++-memb-*_
_++-memb-+_ : (F : *-Fin f m) (G : *-Fin g n) â†’ elem F + elem G âˆˆ[ F ++-gen G ]
F ++-memb-+ G = ++-âˆˆË¡ (memb F) +âˆˆ ++-âˆˆÊ³ ((memb G))

_++-memb-*_ : (F : *-Fin f m) (G : *-Fin g n) â†’ elem F * elem G âˆˆ[ F ++-gen G ]
F ++-memb-* G = ++-âˆˆË¡ (memb F) *âˆˆ ++-âˆˆÊ³ (memb G)

-- closure for derivatives of the concatenation of new generators
infixr 8 _++-closed_
_++-closed_ :
    âˆ€ (F : *-Fin f m) (G : *-Fin g n) (a : Î£) {h} â†’
    h âˆˆ (F ++-gen G) â†’
    -----------------------------------------------
    Î´ h a âˆˆ[ F ++-gen G ]
    
_++-closed_ F G a hâˆˆfs++gs with âˆˆáµ¥-++ hâˆˆfs++gs
... | injâ‚ hâˆˆfs = ++-âˆˆË¡ (closed F a hâˆˆfs)
... | injâ‚‚ hâˆˆgs = ++-âˆˆÊ³ (closed G a hâˆˆgs)
```

# Closure properties of *-finite series


## Scalar multiplication

```
-- same list of generators
*-Fin-Â· : âˆ€ {c} â†’ *-Fin f n â†’ *-Fin (c Â· f) n
*-Fin-Â· F = *-Fin[ gen F , _ Â·âˆˆ memb F , closed F ]
```

## Addition

```
-- just concatenate the generators
*-Fin-+ : *-Fin f m â†’ *-Fin g n â†’ *-Fin (f + g) (m +â„• n)
*-Fin-+ {f = f} {g} F G = *-Fin[ F ++-gen G , F ++-memb-+ G , F ++-closed G ]
```

## Product

```
-- just concatenate the generators
*-Fin-* : *-Fin f m â†’ *-Fin g n â†’ *-Fin (f * g) (m +â„• n)
*-Fin-* {f = f} {g} F G = *-Fin[ F ++-gen G , F ++-memb-* G , F ++-closed G ]
```

## Left derivative

```
-- helper lemma
-- Î´-gen : âˆ€ {Î£} {f : A âŸª Î£ âŸ«} {gs : Vec (A âŸª Î£ âŸ«) m} â†’ f âˆˆ[ gs ] â†’ (a : Î£) â†’ Î´ f a âˆˆ[ gs ++ map (Î» g â†’ Î´ g a) gs ]
-- Î´-gen (const c _) a = zeroâˆˆ _
-- Î´-gen (base fâˆˆgs) a = base (âˆˆ-++Ê³ (âˆˆ-map fâˆˆgs))
-- Î´-gen (gâˆˆ[gs] +âˆˆ hâˆˆ[gs]) a = Î´-gen gâˆˆ[gs] a +âˆˆ Î´-gen hâˆˆ[gs] a
-- Î´-gen (gâˆˆ[gs] â§¢âˆˆ hâˆˆ[gs]) a = Î´-gen gâˆˆ[gs] a â§¢âˆˆ ++-âˆˆË¡ hâˆˆ[gs] +âˆˆ ++-âˆˆË¡ gâˆˆ[gs] â§¢âˆˆ Î´-gen hâˆˆ[gs] a
-- Î´-gen (cong gâ‰ˆf gâˆˆ[gs]) a = cong (Î´-â‰ˆ gâ‰ˆf a) (Î´-gen gâˆˆ[gs] a)

-- Î´-diff : âˆ€ {Î£} {f : A âŸª Î£ âŸ«} (SFf : SF f) {g} â†’ g âˆˆ[ gen SFf ] â†’ (a : Î£) â†’ Î´ g a âˆˆ[ gen SFf ]
-- Î´-diff = {!   !}

-- closure under left derivative
-- same generators
*-Fin-Î´ : *-Fin f m â†’ âˆ€ a â†’ *-Fin (Î´ f a) m
*-Fin-Î´ F a = *-Fin[ gen F , Î´-closed F a (memb F) , closed F ]

-- for every polynomial expression in n variables,
-- if each variable evaluates to a *-finite series,
-- then the whole expression evaluates to a *-finite series too
-- *-Fin-poly : âˆ€ {n} {Ï±} â†’ (Î± : PolyExpr (Var n)) â†’ (âˆ€ x â†’ *-Fin (Ï± x)) *-Fin (âŸ¦ Î± âŸ§áµ¥ Ï±)
-- *-Fin-poly Î± = ?
```